package com.example.finger_detector_test;

import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.net.Uri;
import android.os.Environment;
import android.provider.ContactsContract;
import android.provider.MediaStore;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ListPopupWindow;
import android.widget.TextView;
import android.widget.Toast;

import org.opencv.android.OpenCVLoader;
import org.opencv.android.Utils;
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfInt;
import org.opencv.core.MatOfInt4;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.dnn.Importer;
import org.opencv.imgproc.Imgproc;
import org.opencv.imgproc.Moments;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

public class MainActivity extends AppCompatActivity {

    private Button photoshot;
    private Button photoprocess;
    private ImageView photoview;

    private TextView xpos;
    private TextView ypos;

    private Uri imageUri;

    public static final int TAKE_PHOTO = 1; //拍照
    public static final int CROP_PHOTO = 2; //图像裁剪

    static {
        if (!OpenCVLoader.initDebug()) {
            Log.d("zz", "init failed");
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        photoshot = (Button) findViewById(R.id.photo_btn);
        photoview = (ImageView) findViewById(R.id.imageView);
        photoprocess = (Button) findViewById(R.id.process_btn);

        xpos = (TextView) findViewById(R.id.xtextView2);
        ypos = (TextView) findViewById(R.id.ytextView);

        photoshot.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //尝试创建File对象
                File outputImage = new File(Environment.getExternalStorageDirectory(),"tempImage.jpg");
                try{
                    if(outputImage.exists())
                        outputImage.delete();
                    outputImage.createNewFile();
                }catch (IOException e){
                    e.printStackTrace();
                }
                imageUri = Uri.fromFile(outputImage);
                Intent intent = new Intent("android.media.action.IMAGE_CAPTURE");
                intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
                startActivityForResult(intent, TAKE_PHOTO);
            }
        });

        photoprocess.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //判断文件是否存在
                File outputImage = new File(Environment.getExternalStorageDirectory(),"tempImage.jpg");
                try{
                    if(outputImage.exists()){
                        //提取照片
                        imageUri = Uri.fromFile(outputImage);
                        Bitmap bitmap = BitmapFactory.decodeStream( //将图片保存在bitmap中
                                getContentResolver().openInputStream(imageUri));
                        photoview.setImageBitmap(bitmap);

                        Mat blurMat = new Mat();
                        Mat rgbMat = new Mat();
                        Mat YCrCbMat = new Mat();
                        Mat CannyMat = new Mat();
                        Mat transferMat = new Mat();
                        Mat morphMat = new Mat();
                        Mat threshMat = new Mat();
                        Mat grayMat = new Mat();
                        Utils.bitmapToMat(bitmap,rgbMat);
                        //去噪声
                        Imgproc.medianBlur(rgbMat,blurMat,3);

                        //转为YCrCb彩色空间
                        Imgproc.cvtColor(blurMat,YCrCbMat,Imgproc.COLOR_RGB2YCrCb);

                        //二值化
                        Bitmap transfer = Bitmap.createBitmap(bitmap.getWidth(),bitmap.getHeight(),
                                Bitmap.Config.RGB_565);
                        //这句不是必要的
                        //Utils.matToBitmap(YCrCbMat,transfer);

                        int xsize = bitmap.getWidth();
                        int ysize = bitmap.getHeight();
                        for(int i=0;i<ysize;i++){
                            for(int j=0;j<xsize;j++){
                                if(YCrCbMat.get(i,j)[1] > 133 &&YCrCbMat.get(i,j)[1] <173
                                        && YCrCbMat.get(i,j)[2] > 77 && YCrCbMat.get(i,j)[2] <127)
                                    transfer.setPixel(j,i, Color.WHITE);
                                else
                                    transfer.setPixel(j,i,Color.BLACK);
                            }
                        }
                        Utils.bitmapToMat(transfer,transferMat);
                        //二值化图像
                        Imgproc.threshold(transferMat,threshMat,96,255,Imgproc.THRESH_BINARY);
                        //求重心
                        Imgproc.cvtColor(threshMat,grayMat,Imgproc.COLOR_RGB2GRAY);
                        Moments moments = Imgproc.moments(grayMat,false);
                        double m00 = moments.m00;
                        double xbar = moments.m10/m00;
                        double ybar = moments.m01/m00;
                        Point gravity = new Point(xbar,ybar);

                        //对图像进行开运算
                        Mat kernel= Imgproc.getStructuringElement(Imgproc.MORPH_RECT,new Size(3,3));
                        Imgproc.morphologyEx(transferMat,morphMat,Imgproc.MORPH_OPEN,kernel);
                        Imgproc.resize(transferMat,transferMat,new Size(bitmap.getWidth(),bitmap.getHeight()),0,0,Imgproc.INTER_LINEAR);
                        Bitmap output= Bitmap.createBitmap(bitmap.getWidth(),bitmap.getHeight(),
                                Bitmap.Config.RGB_565);
                        //canny算法求边缘
                        /*
                        Imgproc.Canny(transferMat,CannyMat,10,100);
                        */
                        /*
                        //求取边界
                        Imgproc.threshold(CannyMat,grayMat,0,255,Imgproc.THRESH_BINARY);
                        */
                        //Imgproc.cvtColor(CannyMat,grayMat,Imgproc.COLOR_RGB2GRAY);
                        Mat copy = new Mat();
                        morphMat.copyTo(copy);
                        Imgproc.Canny(morphMat,CannyMat,10,100);
                        Imgproc.cvtColor(copy,copy,Imgproc.COLOR_RGB2GRAY);
                        Vector<MatOfPoint> pointsOfEdge = new Vector<>();
                        Mat hire = new Mat();
                        Imgproc.findContours(copy,pointsOfEdge,hire,
                                Imgproc.RETR_LIST,
                                Imgproc.CHAIN_APPROX_NONE);
                        //得到轮廓点集pointsOfEdges
                        //多边形拟合，先将边集转换为MatOfPoint2f
                        List<MatOfPoint2f> newContours = new ArrayList<>();
                        for(MatOfPoint point:pointsOfEdge){
                            MatOfPoint2f newPoint = new MatOfPoint2f(point.toArray());
                            newContours.add(newPoint);
                        }
                        Vector<MatOfPoint2f> consequence = new Vector<>();
                        for(int i=0;i<newContours.size();i++){
                            MatOfPoint2f first = newContours.get(i);
                            MatOfPoint2f second = new MatOfPoint2f();
                            Imgproc.approxPolyDP(first,second,100,true);
                            consequence.add(second);
                        }
                        List<MatOfPoint> polyedges = new ArrayList<>();
                        for(MatOfPoint2f point : consequence){
                            MatOfPoint newPoint = new MatOfPoint(point.toArray());
                            polyedges.add(newPoint);
                        }

                        //得到多边形点集
                        //凸包求边界
                        MatOfInt hullInt = new MatOfInt();
                        Vector<MatOfPoint> hullPoints = new Vector<>();
                        Vector<Point> hullPointList = new Vector<>();
                        MatOfPoint hullPointMat = new MatOfPoint();
                        Vector<MatOfInt> hullInt4 = new Vector<>();
                        for(int k=0;k<polyedges.size();k++){
                            Imgproc.convexHull(polyedges.get(k),hullInt);
                            for(int j=0;j<hullInt.toList().size();j++){
                                hullPointList.add(polyedges.get(k).toList().get(hullInt.toList().get(j)));
                            }
                            hullInt4.add(hullInt);
                            hullPointMat.fromList(hullPointList);
                            hullPoints.add(hullPointMat);
                        }

                        //从polyedges中选取距离
                        double constraint1 = bitmap.getHeight()/4;
                        double constraint2 = bitmap.getWidth()/4;
                        double constraint = constraint1*constraint1+constraint2*constraint2;
                        List<Point> allpolypoints = new ArrayList<>();
                        List<Point> allhullpoints = new ArrayList<>();
                        //将所有polyedges节点放在allpolypoints中
                        //所有凸包节点放在allhullpoints中
                        for(int i=0;i<polyedges.size();i++){
                            MatOfPoint node = polyedges.get(i);
                            Point[] points = node.toArray();
                            for(int j=0;j<points.length;j++)
                                allpolypoints.add(points[j]);
                        }
                        for(int i=0;i<hullPoints.size();i++){
                            MatOfPoint node = hullPoints.get(i);
                            Point[] points = node.toArray();
                            for(int j=0;j<points.length;j++)
                                allhullpoints.add(points[j]);
                        }
                        List<Point> fingerTips = new ArrayList<>();
                        for(int i=1;i<allpolypoints.size()-1;i++){
                            Point last = allpolypoints.get(i-1);
                            Point iter = allpolypoints.get(i);
                            Point next = allpolypoints.get(i+1);
                            if(iter.y < ybar - constraint1/2){
                                double multi = (last.x-iter.x)*(next.x-iter.x)+(last.y-iter.y)*(next.y-iter.y);
                                double modex1 = Math.sqrt(Math.pow(last.x-iter.x,2) + Math.pow(last.y-iter.y,2));
                                double modex2 = Math.sqrt(Math.pow(next.y-iter.y,2) + Math.pow(next.y-iter.y,2));
                                double cosine = multi/(modex1*modex2);
                                double distance = (iter.x-xbar)*(iter.x-xbar)+(iter.y-ybar)*(iter.y-ybar);
                                if(cosine > 0 && cosine <1){
                                    if(distance >= constraint){
                                        fingerTips.add(iter);
                                    }
                                }

                                else if(cosine < 0 && cosine > -1){
                                    double distancelast = (iter.x-last.x)*(iter.x-last.x)+(iter.y-last.y)*(iter.y-last.y);
                                    double distancenext = (iter.x-next.x)*(iter.x-next.x)+(iter.y-next.y)*(iter.y-next.y);
                                    if(distance >= distancelast && distance >= distancenext)
                                        fingerTips.add(iter);
                                }

                            }
                        }
                        for(int k=1;k<allhullpoints.size()-1;k++){
                            Point last = allhullpoints.get(k-1);
                            Point iter = allhullpoints.get(k);
                            Point next = allhullpoints.get(k+1);
                            if(iter.y < ybar){
                                double multi = (last.x-iter.x)*(next.x-iter.x)+(last.y-iter.y)*(next.y-iter.y);
                                double modex1 = Math.sqrt(Math.pow(last.x-iter.x,2) + Math.pow(last.y-iter.y,2));
                                double modex2 = Math.sqrt(Math.pow(next.y-iter.y,2) + Math.pow(next.y-iter.y,2));
                                double cosine = multi/(modex1*modex2);
                                double distance = (iter.x-xbar)*(iter.x-xbar)+(iter.y-ybar)*(iter.y-ybar);
                                if(cosine < 0 && cosine > -1){
                                    if(distance >= constraint*constraint){
                                        int l=0;
                                        while(l<fingerTips.size()){
                                            if(fingerTips.get(l).x == iter.x && fingerTips.get(l).y == iter.y)
                                                break;
                                            else
                                                fingerTips.add(iter);
                                            l++;
                                            }
                                        }
                                    else if(cosine > 0 && cosine <1 && fingerTips.size() == 0)
                                        fingerTips.add(iter);
                                }
                            }
                        }
                        for(Point point : fingerTips){
                            Imgproc.circle(rgbMat,point,30,new Scalar(255,0,0,255),3);
                            Imgproc.line(rgbMat,point,gravity,new Scalar(255,0,0,255),3);
                        }
                        /*
                        List<Integer> valleys = new ArrayList<>();
                        List<MatOfInt4> convexDefect = new ArrayList<>();
                        for(int i=0;i<polyedges.size();i++){
                            MatOfInt4 element = new MatOfInt4();
                            Imgproc.convexityDefects(polyedges.get(i),hullInt4.get(i),element);
                            convexDefect.add(element);
                            Point[] data = polyedges.get(i).toArray();
                            valleys = element.toList();
                            for(int j=0;j<valleys.size();j=j+4){
                                Point defect = data[valleys.get(j+2)];
                                Imgproc.circle(CannyMat, defect, 20, new Scalar(255, 255, 0, 255), 5);
                                Imgproc.line(CannyMat, defect, gravity, new Scalar(255, 0, 0, 255), 2);
                            }
                        }
                        */
                        //Imgproc.drawContours(CannyMat,hullPoints,-1,new Scalar(255,0,0,255),1);
                        Utils.matToBitmap(rgbMat,output);

                        output.setPixel((int)xbar,(int)ybar,Color.YELLOW);
                        xpos.setText("手指个数：");
                        ypos.setText(Integer.toString(fingerTips.size()));
                        photoview.setImageBitmap(output);

                        //Utils.matToBitmap(YCrCbMat,bitmap);
                        //photoview.setImageBitmap(bitmap);
                        Toast toast = Toast.makeText(getApplicationContext(),"凸包",Toast.LENGTH_SHORT);
                        toast.show();
                    }
                    else{
                        Context context = getApplicationContext();
                        CharSequence text = "请先进行拍照";
                        int duration = Toast.LENGTH_SHORT;
                        Toast toast = Toast.makeText(context,text,duration);
                        toast.show();
                    }
                }
                catch (Exception e){
                    Toast toast = Toast.makeText(getApplicationContext(),e.toString(),Toast.LENGTH_SHORT);
                    toast.show();
                }
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode,Intent data){
        switch (requestCode){
            case TAKE_PHOTO:
                if(resultCode == RESULT_OK){
                    Intent intent = new Intent("com.android.camera.action.CROP");
                    intent.setDataAndType(imageUri,"image/*");
                    intent.putExtra("scale",true);
                    intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);
                    startActivityForResult(intent,CROP_PHOTO);  //图片裁剪
                }
                break;
            case CROP_PHOTO:
                if(resultCode == RESULT_OK){
                    try {
                        Bitmap bitmap = BitmapFactory.decodeStream(
                                getContentResolver().openInputStream(imageUri));
                        photoview.setImageBitmap(bitmap);
                    }catch (FileNotFoundException e){
                        e.printStackTrace();
                    }
                }
                    break;
                default:
                    break;

        }
    }

}
